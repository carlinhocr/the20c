import json
import os

JSON_FILE = "acs_objects.json"
ASM_FILE  = "acs_objects.asm"


def bool_to_byte(value):
    """Convert a boolean (or truthy string) to 1 or 0."""
    if isinstance(value, bool):
        return 1 if value else 0
    if isinstance(value, str):
        return 1 if value.lower() in ("true", "1", "yes") else 0
    return 1 if value else 0


def sanitize_id(name):
    """Turn an object name into a safe ASM label prefix (lowercase, spaces→_)."""
    return name.strip().lower().replace(" ", "_").replace("-", "_")


def to_asm(objects):
    lines = []
    lines.append("; ============================================================")
    lines.append(";  ACS Objects — auto-generated by acs_objects_to_asm.py")
    lines.append("; ============================================================")
    lines.append("")

    # ── Object index table (pointer to the start of each object record) ──────
    lines.append("objects_index:")
    for index, (key, obj) in enumerate(objects.items()):
        obj_id = obj.get("ObjectID", str(index)).strip()
        label  = f"object_{obj_id}"
        name   = obj.get("Name", key)
        lines.append(f"  .word {label}_id  ; {name}")
    lines.append(f"objects_index_record_length:")
    lines.append(f"  .byte 2  ; each objects_index entry is 1 .word (2 bytes)")
    lines.append("")

    # ── Pointer table ────────────────────────────────────────
    lines.append("objects_pointers:")
    offset = 0

    # Captured from object 0 for the offset labels emitted after all entries
    obj0_visible_offset     = None
    obj0_name_offset        = None
    obj0_description_offset = None
    obj0_record_length      = None

    for index, (key, obj) in enumerate(objects.items()):
        obj_id = obj.get("ObjectID", str(index)).strip()
        label  = f"object_{obj_id}"
        name   = obj.get("Name", key)

        start_offset = offset

        lines.append(f"  .word {label}_id          ; {name} id          [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_takeable    ; {name} takeable    [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_visible     ; {name} visible     [{offset},{offset+1}]") ; _vis = offset ; offset += 2
        lines.append(f"  .word {label}_name        ; {name} name        [{offset},{offset+1}]") ; _nam = offset ; offset += 2
        lines.append(f"  .word {label}_description ; {name} description [{offset},{offset+1}]") ; _dsc = offset ; offset += 2

        if index == 0:
            obj0_visible_offset     = _vis
            obj0_name_offset        = _nam
            obj0_description_offset = _dsc
            obj0_record_length      = offset - start_offset  # 10 bytes (5 × .word)

    # ── Offset labels, placed after all object entries ────────────────────────
    lines.append(f"object_visible_offset:")
    lines.append(f"  .byte {obj0_visible_offset}  ; (byte of object_0_visible in objects_pointers)")
    lines.append(f"object_name_offset:")
    lines.append(f"  .byte {obj0_name_offset}  ; (byte of object_0_name in objects_pointers)")
    lines.append(f"object_description_offset:")
    lines.append(f"  .byte {obj0_description_offset}  ; (byte of object_0_description in objects_pointers)")
    lines.append(f"object_record_length:")
    lines.append(f"  .byte {obj0_record_length}  ; (total .word bytes per object record)")
    lines.append("")

    for index, (key, obj) in enumerate(objects.items()):
        obj_id   = obj.get("ObjectID", str(index)).strip()
        label    = f"object_{obj_id}"
        takeable = bool_to_byte(obj.get("Takeable",  False))
        visible  = bool_to_byte(obj.get("Visible",   False))
        name_str = obj.get("Name",        "").replace('"', '\\"')
        desc_str = obj.get("Description", "").replace('"', '\\"')

        lines.append(f"; ── Object {obj_id}: {obj.get('Name', key)} ──────────────────────────")

        # ID
        lines.append(f"{label}_id:")
        lines.append(f'  .byte {obj_id}')
        lines.append("")

        # Takeable
        lines.append(f"{label}_takeable:")
        lines.append(f"  .byte {takeable}")
        lines.append("")

        # Visible
        lines.append(f"{label}_visible:")
        lines.append(f"  .byte {visible}")
        lines.append("")

        # Name
        lines.append(f"{label}_name:")
        lines.append(f'  .ascii "{name_str}"')
        lines.append('  .ascii "e"')
        lines.append("")

        # Description
        lines.append(f"{label}_description:")
        lines.append(f'  .ascii "{desc_str}"')
        lines.append('  .ascii "e"')
        lines.append("")

    # ── Object count constant ─────────────────────────────────
    lines.append("; ── Total object count ──────────────────────────────────────")
    lines.append(f"object_count:")
    lines.append(f"  .byte {len(objects)}")
    lines.append("")

    return "\n".join(lines)


def main():
    if not os.path.exists(JSON_FILE):
        print(f"[ERROR] '{JSON_FILE}' not found. Run the ACS editor first.")
        return

    with open(JSON_FILE, "r", encoding="utf-8") as f:
        objects = json.load(f)

    if not objects:
        print("[WARNING] No objects found in the JSON file.")
        return

    objects = dict(sorted(objects.items(), key=lambda item: int(item[1].get("ObjectID", 0))))

    asm = to_asm(objects)

    with open(ASM_FILE, "w", encoding="utf-8") as f:
        f.write(asm)

    print(f"[OK] Generated '{ASM_FILE}' with {len(objects)} object(s).")
    print("-" * 50)
    print(asm)


if __name__ == "__main__":
    main()