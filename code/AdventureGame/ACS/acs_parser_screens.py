import json
import os
import sys

JSON_FILE    = "acs_screens.json"
OBJECTS_FILE = "acs_objects.json"
PUZZLES_FILE = "acs_puzzles.json"
ACTIONS_FILE = "acs_actions.json"
ASM_FILE     = "acs_screens.asm"


def load_name_to_id(filepath, id_field="ID", name_field="Name"):
    """Load a JSON file and return a dict { name -> id }."""
    if not os.path.exists(filepath):
        print(f"[ERROR] '{filepath}' not found.")
        sys.exit(1)
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    mapping = {}
    for entry in data.values():
        name = entry.get(name_field, "").strip()
        eid  = entry.get(id_field,   "").strip()
        if name and eid:
            mapping[name] = int(eid)
    return mapping


def resolve(name, mapping, label, optional=False):
    """Resolve a name to its numeric ID. If optional and empty, return 255 (no ref)."""
    name = name.strip()
    if not name:
        if optional:
            return 255
        return 255   # empty slot → 0xFF sentinel
    if name not in mapping:
        print(f"[ERROR] '{name}' not found in {label}. Available: {list(mapping.keys())}")
        sys.exit(1)
    return mapping[name]


# Number of .word entries per screen in the pointer table.
# id, name, north, south, east, west, object1..6, puzzle1..2, action1..6,
# screen_object_offset, description, ascii = 23 entries × 2 bytes = 46 bytes/screen.
ENTRIES_PER_SCREEN = 23          # total .word entries per screen (including screen_object_offset)
BYTES_PER_ENTRY    = 2           # each pointer is a .word (2 bytes)
BYTES_PER_SCREEN   = ENTRIES_PER_SCREEN * BYTES_PER_ENTRY   # 46

# object1 is entry index 6 (0-based) within each screen block:
#   0:id  1:name  2:north  3:south  4:east  5:west  6:object1 ...
OBJECT1_ENTRY_INDEX = 6
OBJECT1_BYTE_OFFSET = OBJECT1_ENTRY_INDEX * BYTES_PER_ENTRY  # 12


def screen_object1_pointer_byte(screen_index):
    """
    Return the absolute byte offset of screen_N_object1 inside screens_pointers.
    screen_index is the 0-based position of the screen in the sorted list.
    """
    return screen_index * BYTES_PER_SCREEN + OBJECT1_BYTE_OFFSET


def to_asm(screens, object_ids, puzzle_ids, action_ids, screen_ids):
    lines = []
    lines.append("; ============================================================")
    lines.append(";  ACS Screens — auto-generated by acs_screens_to_asm.py")
    lines.append("; ============================================================")
    lines.append("")

    # ── Pointer table ────────────────────────────────────────
    lines.append("screens_pointers:")
    offset = 0
    screen_0_obj1_byte         = None
    screen_0_puzzle1_byte      = None
    screen_0_action1_byte      = None
    screen_0_description_byte  = None
    screen_0_ascii_byte        = None
    screen_0_record_length     = None
    screen_0_name              = None
    for index, (key, scr) in enumerate(screens.items()):
        scr_id = scr.get("ID", str(index)).strip()
        label  = f"screen_{scr_id}"
        name   = scr.get("Name", key)

        # Byte offset of this screen's object1 entry in the pointer table.
        obj1_ptr_byte = screen_object1_pointer_byte(index)
        start_offset  = offset

        lines.append(f"  .word {label}_id                ; {name} id                [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_name              ; {name} name              [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_north             ; {name} north             [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_south             ; {name} south             [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_east              ; {name} east              [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_west              ; {name} west              [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_object1           ; {name} object1           [{offset},{offset+1}]") ; _obj1 = offset ; offset += 2
        lines.append(f"  .word {label}_object2           ; {name} object2           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_object3           ; {name} object3           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_object4           ; {name} object4           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_object5           ; {name} object5           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_object6           ; {name} object6           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_puzzle1           ; {name} puzzle1           [{offset},{offset+1}]") ; _puz1 = offset ; offset += 2
        lines.append(f"  .word {label}_puzzle2           ; {name} puzzle2           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_action1           ; {name} action1           [{offset},{offset+1}]") ; _act1 = offset ; offset += 2
        lines.append(f"  .word {label}_action2           ; {name} action2           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_action3           ; {name} action3           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_action4           ; {name} action4           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_action5           ; {name} action5           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_action6           ; {name} action6           [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_description       ; {name} description       [{offset},{offset+1}]") ; _desc = offset ; offset += 2
        lines.append(f"  .word {label}_ascii             ; {name} ascii             [{offset},{offset+1}]") ; _asc  = offset ; offset += 2

        if index == 0:
            screen_0_obj1_byte        = _obj1
            screen_0_puzzle1_byte     = _puz1
            screen_0_action1_byte     = _act1
            screen_0_description_byte = _desc
            screen_0_ascii_byte       = _asc
            screen_0_record_length    = offset - start_offset  # 44 bytes (22 × .word)
            screen_0_name             = name

    # ── Extra fields for screen 0, placed after all screen entries ────────────
    lines.append(f"screen_object_offset:")
    lines.append(f"  .byte {screen_0_obj1_byte}  ; (byte of screen_0_object1 in screens_pointers)")
    lines.append(f"screen_puzzle_offset:")
    lines.append(f"  .byte {screen_0_puzzle1_byte}  ; (byte of screen_0_puzzle1 in screens_pointers)")
    lines.append(f"screen_action_offset:")
    lines.append(f"  .byte {screen_0_action1_byte}  ; (byte of screen_0_action1 in screens_pointers)")
    lines.append(f"screen_description_offset:")
    lines.append(f"  .byte {screen_0_description_byte}  ; (byte of screen_0_description in screens_pointers)")
    lines.append(f"screen_ascii_offset:")
    lines.append(f"  .byte {screen_0_ascii_byte}  ; (byte of screen_0_ascii in screens_pointers)")
    lines.append(f"screen_record_length:")
    lines.append(f"  .byte {screen_0_record_length}  ; (total .word bytes per screen record)")
    lines.append("")

    for index, (key, scr) in enumerate(screens.items()):
        scr_id    = scr.get("ID",          str(index)).strip()
        label     = f"screen_{scr_id}"
        name_str  = scr.get("Name",        "").replace('"', '\\"')
        desc_str  = scr.get("Description", "").replace('"', '\\"')
        ascii_str = scr.get("AsciiDrawing","").replace('"', '\\"').replace("\n", "\\n")

        # exits → numeric screen IDs (255 = no exit)
        north_id = resolve(scr.get("North", ""), screen_ids, JSON_FILE,    optional=True)
        south_id = resolve(scr.get("South", ""), screen_ids, JSON_FILE,    optional=True)
        east_id  = resolve(scr.get("East",  ""), screen_ids, JSON_FILE,    optional=True)
        west_id  = resolve(scr.get("West",  ""), screen_ids, JSON_FILE,    optional=True)

        # objects → numeric IDs (255 = empty slot)
        obj_ids = [
            resolve(scr.get(f"Object{i}", ""), object_ids, OBJECTS_FILE, optional=True)
            for i in range(1, 7)
        ]

        # puzzles → numeric IDs (255 = empty slot)
        puz1_id = resolve(scr.get("Puzzle1", ""), puzzle_ids, PUZZLES_FILE, optional=True)
        puz2_id = resolve(scr.get("Puzzle2", ""), puzzle_ids, PUZZLES_FILE, optional=True)

        # actions → numeric IDs (255 = empty slot)
        act_ids = [
            resolve(scr.get(f"Action{i}", ""), action_ids, ACTIONS_FILE, optional=True)
            for i in range(1, 7)
        ]

        lines.append(f"; ── Screen {scr_id}: {scr.get('Name', key)} ──────────────────────────")

        # ID
        lines.append(f"{label}_id:")
        lines.append(f"  .byte {scr_id}")
        lines.append("")

        # Name
        lines.append(f"{label}_name:")
        lines.append(f'  .ascii "{name_str}"')
        lines.append('  .ascii "e"')
        lines.append("")

        # Exits → numeric screen IDs
        for direction, did, dname in [
            ("north", north_id, scr.get("North", "")),
            ("south", south_id, scr.get("South", "")),
            ("east",  east_id,  scr.get("East",  "")),
            ("west",  west_id,  scr.get("West",  "")),
        ]:
            comment = dname if dname.strip() else "none"
            lines.append(f"{label}_{direction}:")
            lines.append(f"  .byte {did}  ; {comment}")
            lines.append("")

        # Objects → numeric IDs
        for i, oid in enumerate(obj_ids, 1):
            obj_name = scr.get(f"Object{i}", "") or "none"
            lines.append(f"{label}_object{i}:")
            lines.append(f"  .byte {oid}  ; {obj_name}")
            lines.append("")

        # Puzzles → numeric IDs
        for i, (pid, pname) in enumerate(
            [(puz1_id, scr.get("Puzzle1", "")), (puz2_id, scr.get("Puzzle2", ""))], 1
        ):
            comment = pname if pname.strip() else "none"
            lines.append(f"{label}_puzzle{i}:")
            lines.append(f"  .byte {pid}  ; {comment}")
            lines.append("")

        # Actions → numeric IDs
        for i, aid in enumerate(act_ids, 1):
            act_name = scr.get(f"Action{i}", "") or "none"
            lines.append(f"{label}_action{i}:")
            lines.append(f"  .byte {aid}  ; {act_name}")
            lines.append("")

        # Description
        lines.append(f"{label}_description:")
        lines.append(f'  .ascii "{desc_str}"')
        lines.append('  .ascii "e"')
        lines.append("")

        # AsciiDrawing
        lines.append(f"{label}_ascii:")
        lines.append(f'  .ascii "{ascii_str}"')
        lines.append('  .ascii "e"')
        lines.append("")

    # ── Screen count constant ─────────────────────────────────
    lines.append("; ── Total screen count ──────────────────────────────────────")
    lines.append("screen_count:")
    lines.append(f"  .byte {len(screens)}")
    lines.append("")

    return "\n".join(lines)


def main():
    # ── Load lookup tables ────────────────────────────────────
    object_ids = load_name_to_id(OBJECTS_FILE, id_field="ObjectID", name_field="Name")
    puzzle_ids = load_name_to_id(PUZZLES_FILE, id_field="ID",       name_field="Name")
    action_ids = load_name_to_id(ACTIONS_FILE, id_field="ID",       name_field="Name")
    screen_ids = load_name_to_id(JSON_FILE,    id_field="ID",       name_field="Name")

    # ── Load screens ──────────────────────────────────────────
    if not os.path.exists(JSON_FILE):
        print(f"[ERROR] '{JSON_FILE}' not found. Run the ACS editor first.")
        return

    with open(JSON_FILE, "r", encoding="utf-8") as f:
        screens = json.load(f)

    if not screens:
        print("[WARNING] No screens found in the JSON file.")
        return

    screens = dict(sorted(screens.items(), key=lambda item: int(item[1].get("ID", 0))))

    asm = to_asm(screens, object_ids, puzzle_ids, action_ids, screen_ids)

    with open(ASM_FILE, "w", encoding="utf-8") as f:
        f.write(asm)

    print(f"[OK] Generated '{ASM_FILE}' with {len(screens)} screen(s).")
    print("-" * 50)
    print(asm)


if __name__ == "__main__":
    main()