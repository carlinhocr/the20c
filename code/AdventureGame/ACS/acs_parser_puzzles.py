import json
import os
import sys

JSON_FILE    = "acs_puzzles.json"
ACTIONS_FILE = "acs_actions.json"
OBJECTS_FILE = "acs_objects.json"
ASM_FILE     = "acs_puzzles.asm"


def bool_to_byte(value):
    if isinstance(value, bool):
        return 1 if value else 0
    if isinstance(value, str):
        return 1 if value.lower() in ("true", "1", "yes") else 0
    return 1 if value else 0


def load_name_to_id(filepath, id_field="ID", name_field="Name"):
    """Load a JSON file and return a dict { name -> id }."""
    if not os.path.exists(filepath):
        print(f"[ERROR] '{filepath}' not found.")
        sys.exit(1)
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    mapping = {}
    for entry in data.values():
        name = entry.get(name_field, "").strip()
        eid  = entry.get(id_field,   "").strip()
        if name and eid:
            mapping[name] = int(eid)
    return mapping


def resolve(name, mapping, label):
    """Resolve a name to its numeric ID; abort with a clear message if not found."""
    name = name.strip()
    if name not in mapping:
        print(f"[ERROR] '{name}' not found in {label}. Available: {list(mapping.keys())}")
        sys.exit(1)
    return mapping[name]


def to_asm(puzzles, action_ids, object_ids):
    lines = []
    lines.append("; ============================================================")
    lines.append(";  ACS Puzzles — auto-generated by acs_puzzles_to_asm.py")
    lines.append("; ============================================================")
    lines.append("")

    # ── Pointer table ────────────────────────────────────────
    lines.append("puzzles_pointers:")
    offset = 0

    # Captured from puzzle 0 for offset labels emitted after all entries
    puz0_action_offset              = None
    puz0_solved_offset              = None
    puz0_desc_solved_offset         = None
    puz0_desc_notsolved_offset      = None
    puz0_record_length              = None

    for index, (key, puz) in enumerate(puzzles.items()):
        puz_id = puz.get("ID", str(index)).strip()
        label  = f"puzzle_{puz_id}"
        name   = puz.get("Name", key)

        start_offset = offset

        lines.append(f"  .word {label}_id                   ; {name} id                   [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_name                 ; {name} name                 [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_action               ; {name} action               [{offset},{offset+1}]") ; _act = offset ; offset += 2
        lines.append(f"  .word {label}_object1              ; {name} object1              [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_object2              ; {name} object2              [{offset},{offset+1}]") ; offset += 2
        lines.append(f"  .word {label}_solved               ; {name} solved               [{offset},{offset+1}]") ; _sol = offset ; offset += 2
        lines.append(f"  .word {label}_description_solved   ; {name} description_solved   [{offset},{offset+1}]") ; _dsc_sol = offset ; offset += 2
        lines.append(f"  .word {label}_description_notsolved; {name} description_notsolved[{offset},{offset+1}]") ; _dsc_not = offset ; offset += 2

        if index == 0:
            puz0_action_offset         = _act
            puz0_solved_offset         = _sol
            puz0_desc_solved_offset    = _dsc_sol
            puz0_desc_notsolved_offset = _dsc_not
            puz0_record_length         = offset - start_offset  # 16 bytes (8 × .word)

    # ── Offset labels, placed after all puzzle entries ────────────────────────
    lines.append(f"puzzle_action_offset:")
    lines.append(f"  .byte {puz0_action_offset}  ; (byte of puzzle_0_action in puzzles_pointers)")
    lines.append(f"puzzle_solved_offset:")
    lines.append(f"  .byte {puz0_solved_offset}  ; (byte of puzzle_0_solved in puzzles_pointers)")
    lines.append(f"puzzle_description_solved_offset:")
    lines.append(f"  .byte {puz0_desc_solved_offset}  ; (byte of puzzle_0_description_solved in puzzles_pointers)")
    lines.append(f"puzzle_description_notsolved_offset:")
    lines.append(f"  .byte {puz0_desc_notsolved_offset}  ; (byte of puzzle_0_description_notsolved in puzzles_pointers)")
    lines.append(f"puzzle_record_length:")
    lines.append(f"  .byte {puz0_record_length}  ; (total .word bytes per puzzle record)")
    lines.append("")

    for index, (key, puz) in enumerate(puzzles.items()):
        puz_id    = puz.get("ID",                   str(index)).strip()
        label     = f"puzzle_{puz_id}"
        name_str  = puz.get("Name",                 "").replace('"', '\\"')
        solved    = bool_to_byte(puz.get("Solved",  False))
        desc_sol  = puz.get("DescriptionSolved",    "").replace('"', '\\"')
        desc_not  = puz.get("DescriptionNotSolved", "").replace('"', '\\"')

        action_id  = resolve(puz.get("Action",  ""), action_ids, ACTIONS_FILE)
        object1_id = resolve(puz.get("Object1", ""), object_ids, OBJECTS_FILE)
        object2_id = resolve(puz.get("Object2", ""), object_ids, OBJECTS_FILE)

        lines.append(f"; ── Puzzle {puz_id}: {puz.get('Name', key)} ──────────────────────────")

        # ID
        lines.append(f"{label}_id:")
        lines.append(f"  .byte {puz_id}")
        lines.append("")

        # Name
        lines.append(f"{label}_name:")
        lines.append(f'  .ascii "{name_str}"')
        lines.append('  .ascii "e"')
        lines.append("")

        # Action → numeric ID
        lines.append(f"{label}_action:")
        lines.append(f"  .byte {action_id}  ; {puz.get('Action', '')}")
        lines.append("")

        # Object1 → numeric ID
        lines.append(f"{label}_object1:")
        lines.append(f"  .byte {object1_id}  ; {puz.get('Object1', '')}")
        lines.append("")

        # Object2 → numeric ID
        lines.append(f"{label}_object2:")
        lines.append(f"  .byte {object2_id}  ; {puz.get('Object2', '')}")
        lines.append("")

        # Solved
        lines.append(f"{label}_solved:")
        lines.append(f"  .byte {solved}")
        lines.append("")

        # DescriptionSolved
        lines.append(f"{label}_description_solved:")
        lines.append(f'  .ascii "{desc_sol}"')
        lines.append('  .ascii "e"')
        lines.append("")

        # DescriptionNotSolved
        lines.append(f"{label}_description_notsolved:")
        lines.append(f'  .ascii "{desc_not}"')
        lines.append('  .ascii "e"')
        lines.append("")

    # ── Puzzle count constant ─────────────────────────────────
    lines.append("; ── Total puzzle count ──────────────────────────────────────")
    lines.append("puzzle_count:")
    lines.append(f"  .byte {len(puzzles)}")
    lines.append("")

    return "\n".join(lines)


def main():
    # ── Load lookup tables ────────────────────────────────────
    action_ids = load_name_to_id(ACTIONS_FILE, id_field="ID", name_field="Name")
    object_ids = load_name_to_id(OBJECTS_FILE, id_field="ObjectID", name_field="Name")

    # ── Load puzzles ──────────────────────────────────────────
    if not os.path.exists(JSON_FILE):
        print(f"[ERROR] '{JSON_FILE}' not found. Run the ACS editor first.")
        return

    with open(JSON_FILE, "r", encoding="utf-8") as f:
        puzzles = json.load(f)

    if not puzzles:
        print("[WARNING] No puzzles found in the JSON file.")
        return

    puzzles = dict(sorted(puzzles.items(), key=lambda item: int(item[1].get("ID", 0))))

    asm = to_asm(puzzles, action_ids, object_ids)

    with open(ASM_FILE, "w", encoding="utf-8") as f:
        f.write(asm)

    print(f"[OK] Generated '{ASM_FILE}' with {len(puzzles)} puzzle(s).")
    print("-" * 50)
    print(asm)


if __name__ == "__main__":
    main()